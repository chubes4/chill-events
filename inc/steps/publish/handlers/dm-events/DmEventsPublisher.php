<?php
/**
 * Data Machine Events Publisher Handler
 * 
 * Creates WordPress event posts with Event Details blocks from imported event data.
 * Handles AI tool calls and direct publishing.
 *
 * @package DmEvents\Steps\Publish\Handlers\DmEvents
 * @since 1.0.0
 */

namespace DmEvents\Steps\Publish\Handlers\DmEvents;

use DmEvents\Events\Event_Data_Manager;
use DmEvents\Steps\Publish\Handlers\DmEvents\DmEventsSettings;

// Prevent direct access
if (!defined('ABSPATH')) {
    exit;
}

/**
 * AI-driven event publisher for Data Machine pipelines
 * 
 * Creates WordPress event posts with Event Details blocks from imported data,
 * handling AI tool calls for description generation and venue taxonomy management.
 * Integrates with block-first architecture and maintains data integrity.
 * 
 * @since 1.0.0
 */
class DmEventsPublisher {
    
    /**
     * Handle AI tool call for event creation
     * 
     * Called by Data Machine publish step with AI tool parameters.
     * Creates event post with Event Details block and handles venue taxonomy.
     * 
     * @param array $parameters AI tool parameters with event data
     * @param array $tool_def Tool definition from Data Machine
     * @return array Result with success status, message, and data
     */
    public function handle_tool_call($parameters, $tool_def = []) {
        $this->log_info('Data Machine Events Publisher: Processing AI tool call', [
            'parameters_keys' => array_keys($parameters),
            'tool_def' => $tool_def
        ]);
        
        // Extract handler configuration (following WordPress handler pattern)
        $handler_config = $tool_def['handler_config'] ?? [];
        
        try {
            // Validate required configuration (following WordPress handler pattern)
            if (empty($handler_config['post_author'])) {
                $error_msg = 'DM Events publish handler missing required post_author configuration';
                do_action('dm_log', 'error', $error_msg, [
                    'handler_config_keys' => array_keys($handler_config),
                    'provided_post_author' => $handler_config['post_author'] ?? 'NOT_SET'
                ]);
                
                return [
                    'success' => false,
                    'error' => $error_msg,
                    'tool_name' => 'create_event'
                ];
            }
            
            // Validate required parameters
            if (empty($parameters['title'])) {
                return [
                    'success' => false,
                    'message' => 'Event title is required'
                ];
            }
            
            if (empty($parameters['description'])) {
                return [
                    'success' => false,
                    'message' => 'Event description is required and must be generated by AI'
                ];
            }
            
            // Create event post
            $post_id = $this->create_event_post($parameters, $tool_def, $handler_config);
            
            if (is_wp_error($post_id)) {
                return [
                    'success' => false,
                    'message' => 'Failed to create event post: ' . $post_id->get_error_message()
                ];
            }
            
            // Handle taxonomy assignments based on settings and merged data
            $merged_parameters = $this->merge_system_and_ai_data($parameters, $handler_config);
            $taxonomy_results = $this->handle_taxonomy_assignments($post_id, $merged_parameters, $tool_def);
            
            // Trigger Event Data Manager sync
            if (class_exists('DmEvents\Events\Event_Data_Manager')) {
                Event_Data_Manager::sync_event_meta($post_id);
            }
            
            $this->log_info('Data Machine Events Publisher: Event created successfully', [
                'post_id' => $post_id,
                'post_url' => get_permalink($post_id),
                'taxonomy_results' => $taxonomy_results
            ]);
            
            return [
                'success' => true,
                'message' => "Event created successfully",
                'data' => [
                    'post_id' => $post_id,
                    'post_url' => get_permalink($post_id),
                    'edit_url' => get_edit_post_link($post_id),
                    'taxonomy_results' => $taxonomy_results
                ]
            ];
            
        } catch (\Exception $e) {
            $this->log_error('Data Machine Events Publisher: Exception during event creation', [
                'exception' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);
            
            return [
                'success' => false,
                'message' => 'Error creating event: ' . $e->getMessage()
            ];
        }
    }
    
    /**
     * Create event post with Event Details block
     * 
     * @param array $event_data Event data from AI tool
     * @param array $tool_def Tool definition with handler config
     * @return int|WP_Error Post ID on success, WP_Error on failure
     */
    private function create_event_post(array $event_data, array $tool_def = [], array $handler_config = []) {
        // Merge system data with AI parameters (system data takes precedence)
        $merged_event_data = $this->merge_system_and_ai_data($event_data, $handler_config);
        
        // Prepare post data
        $post_data = [
            'post_title' => wp_unslash(sanitize_text_field($merged_event_data['title'])),
            'post_content' => $this->generate_event_block_content($merged_event_data),
            'post_status' => $this->get_configured_post_status($tool_def),
            'post_type' => 'dm_events',
            'post_author' => $handler_config['post_author']
        ];
        
        // Create the post
        $post_id = wp_insert_post($post_data, true);
        
        if (is_wp_error($post_id)) {
            $this->log_error('Failed to create event post', [
                'error' => $post_id->get_error_message(),
                'post_data' => $post_data
            ]);
            return $post_id;
        }
        
        $this->log_debug('Event post created', [
            'post_id' => $post_id,
            'title' => $event_data['title']
        ]);
        
        return $post_id;
    }
    
    /**
     * Get configured post status from handler settings
     * 
     * @param array $tool_def Tool definition with handler config
     * @return string Post status (publish, draft, pending, private)
     */
    private function get_configured_post_status(array $tool_def): string {
        $handler_config = $tool_def['handler_config'] ?? [];
        $status = $handler_config['event_post_status'] ?? 'publish';
        return in_array($status, ['publish', 'draft', 'pending', 'private']) ? $status : 'publish';
    }
    
    /**
     * Generate Event Details block content
     * 
     * @param array $event_data Event data
     * @return string Gutenberg block markup
     */
    private function generate_event_block_content(array $event_data): string {
        // Prepare block attributes (address comes from venue term meta, not AI parameters)
        $attributes = [
            'startDate' => sanitize_text_field($event_data['startDate'] ?? ''),
            'endDate' => sanitize_text_field($event_data['endDate'] ?? ''),
            'startTime' => sanitize_text_field($event_data['startTime'] ?? ''),
            'endTime' => sanitize_text_field($event_data['endTime'] ?? ''),
            'venue' => sanitize_text_field($event_data['venue'] ?? ''),
            'artist' => sanitize_text_field($event_data['artist'] ?? ''),
            'price' => sanitize_text_field($event_data['price'] ?? ''),
            'ticketUrl' => esc_url_raw($event_data['ticketUrl'] ?? ''),
            'description' => wp_kses_post($event_data['description'] ?? ''),
            // AI-generated schema fields
            'performerType' => sanitize_text_field($event_data['performerType'] ?? ''),
            'organizerName' => sanitize_text_field($event_data['organizerName'] ?? ''),
            'organizerType' => sanitize_text_field($event_data['organizerType'] ?? ''),
            'priceCurrency' => sanitize_text_field($event_data['priceCurrency'] ?? ''),
            'eventStatus' => sanitize_text_field($event_data['eventStatus'] ?? ''),
            'offerAvailability' => sanitize_text_field($event_data['offerAvailability'] ?? ''),
            // Display flags
            'showVenue' => !empty($event_data['venue']),
            'showArtist' => !empty($event_data['artist']),
            'showPrice' => !empty($event_data['price']),
            'showTicketLink' => !empty($event_data['ticketUrl'])
        ];
        
        // Remove empty attributes
        $attributes = array_filter($attributes, function($value) {
            return $value !== '' && $value !== null;
        });
        
        // Generate block markup
        $json_attributes = wp_json_encode($attributes, JSON_UNESCAPED_SLASHES);
        
        return "<!-- wp:dm-events/event-details $json_attributes /-->";
    }
    
    /**
     * Handle taxonomy assignments for event post
     * 
     * @param int $post_id Post ID
     * @param array $parameters AI tool parameters
     * @param array $tool_def Tool definition with handler config
     * @return array Results of taxonomy assignments
     */
    private function handle_taxonomy_assignments(int $post_id, array $parameters, array $tool_def): array {
        $results = [];
        $handler_config = $tool_def['handler_config'] ?? [];
        
        // Get taxonomies that support 'dm_events' post type
        $taxonomies = get_object_taxonomies('dm_events', 'objects');
        
        foreach ($taxonomies as $taxonomy) {
            if (!$taxonomy->public) {
                continue;
            }
            
            $taxonomy_slug = $taxonomy->name;
            
            // Autonomous venue assignment - always assign from structured data
            if ($taxonomy_slug === 'venue') {
                $venue_name = sanitize_text_field($parameters['venue'] ?? '');
                if (!empty($venue_name)) {
                    $result = $this->assign_taxonomy_from_ai($post_id, $taxonomy_slug, $venue_name, $parameters);
                    if ($result['success']) {
                        $results[$taxonomy_slug] = $result;
                    }
                }
                continue;
            }
            
            $field_key = "taxonomy_{$taxonomy_slug}_selection";
            $selection = $handler_config[$field_key] ?? 'skip';
            
            if ($selection === 'skip') {
                continue;
            }
            
            if ($selection === 'ai_decides') {
                // Handle AI-decided taxonomy from parameters
                if (isset($parameters[$taxonomy_slug])) {
                    $result = $this->assign_taxonomy_from_ai($post_id, $taxonomy_slug, $parameters[$taxonomy_slug], $parameters);
                    $results[$taxonomy_slug] = $result;
                }
            } else {
                // Handle pre-selected term from settings
                $term_id = absint($selection);
                if ($term_id > 0) {
                    $result = $this->assign_specific_term($post_id, $taxonomy_slug, $term_id);
                    $results[$taxonomy_slug] = $result;
                }
            }
        }
        
        return $results;
    }
    
    
    /**
     * Assign taxonomy term based on AI decision
     * 
     * @param int $post_id Post ID
     * @param string $taxonomy_slug Taxonomy slug
     * @param mixed $term_value Term name(s) from AI
     * @param array $all_parameters All AI parameters for venue meta handling
     * @return array Assignment result
     */
    private function assign_taxonomy_from_ai(int $post_id, string $taxonomy_slug, $term_value, array $all_parameters = []): array {
        $taxonomy_obj = get_taxonomy($taxonomy_slug);
        $term_ids = [];
        
        // Handle array of terms or single term
        $terms = is_array($term_value) ? $term_value : [$term_value];
        
        foreach ($terms as $term_name) {
            $term_name = sanitize_text_field($term_name);
            if (empty($term_name)) continue;
            
            // Get or create term
            $term = get_term_by('name', $term_name, $taxonomy_slug);
            if (!$term) {
                $term_result = wp_insert_term($term_name, $taxonomy_slug);
                if (is_wp_error($term_result)) {
                    $this->log_error('Failed to create taxonomy term', [
                        'taxonomy' => $taxonomy_slug,
                        'term_name' => $term_name,
                        'error' => $term_result->get_error_message()
                    ]);
                    continue;
                }
                $term_ids[] = $term_result['term_id'];
                
                // Handle special venue term meta
                if ($taxonomy_slug === 'venue') {
                    $this->add_venue_meta($term_result['term_id'], $term_name, $all_parameters);
                }
            } else {
                $term_ids[] = $term->term_id;
                
                // Also update venue meta for existing venues
                if ($taxonomy_slug === 'venue') {
                    $this->add_venue_meta($term->term_id, $term_name, $all_parameters);
                }
            }
        }
        
        if (!empty($term_ids)) {
            $result = wp_set_object_terms($post_id, $term_ids, $taxonomy_slug);
            if (is_wp_error($result)) {
                return [
                    'success' => false,
                    'taxonomy' => $taxonomy_slug,
                    'error' => $result->get_error_message()
                ];
            }
        }
        
        return [
            'success' => true,
            'taxonomy' => $taxonomy_slug,
            'term_count' => count($term_ids),
            'terms' => $terms
        ];
    }
    
    /**
     * Assign specific pre-selected term
     * 
     * @param int $post_id Post ID
     * @param string $taxonomy_slug Taxonomy slug
     * @param int $term_id Term ID to assign
     * @return array Assignment result
     */
    private function assign_specific_term(int $post_id, string $taxonomy_slug, int $term_id): array {
        $result = wp_set_object_terms($post_id, [$term_id], $taxonomy_slug);
        
        if (is_wp_error($result)) {
            return [
                'success' => false,
                'taxonomy' => $taxonomy_slug,
                'error' => $result->get_error_message()
            ];
        }
        
        $term = get_term($term_id, $taxonomy_slug);
        
        return [
            'success' => true,
            'taxonomy' => $taxonomy_slug,
            'term_count' => 1,
            'terms' => [$term ? $term->name : 'Unknown']
        ];
    }
    
    /**
     * Add venue-specific term meta
     * 
     * @param int $term_id Venue term ID
     * @param string $venue_name Venue name
     * @param array $event_data Event data from AI parameters
     */
    private function add_venue_meta(int $term_id, string $venue_name, array $event_data = []): void {
        // Use Venue_Term_Meta class for proper meta field handling
        $success = \DmEvents\Events\Venues\Venue_Term_Meta::update_venue_meta($term_id, $event_data);
        
        if ($success) {
            $this->log_debug('Updated venue meta using Venue_Term_Meta class', [
                'term_id' => $term_id,
                'venue_name' => $venue_name,
                'event_data_fields' => array_keys($event_data)
            ]);
        } else {
            $this->log_debug('Failed to update venue meta', [
                'term_id' => $term_id,
                'venue_name' => $venue_name
            ]);
        }
    }
    
    /**
     * Log error message
     * 
     * @param string $message Error message
     * @param array $context Additional context
     */
    private function log_error(string $message, array $context = []): void {
        if (function_exists('do_action')) {
            do_action('dm_log', 'error', $message, $context);
        }
    }
    
    /**
     * Log info message
     * 
     * @param string $message Info message
     * @param array $context Additional context
     */
    private function log_info(string $message, array $context = []): void {
        if (function_exists('do_action')) {
            do_action('dm_log', 'info', $message, $context);
        }
    }
    
    /**
     * Log debug message
     * 
     * @param string $message Debug message
     * @param array $context Additional context
     */
    private function log_debug(string $message, array $context = []): void {
        if (function_exists('do_action')) {
            do_action('dm_log', 'debug', $message, $context);
        }
    }
    
    /**
     * Merge system data with AI parameters (system data takes precedence)
     * 
     * @param array $ai_parameters AI-generated parameters 
     * @param array $handler_config Handler configuration containing system data
     * @return array Merged event data with system data taking precedence
     */
    private function merge_system_and_ai_data(array $ai_parameters, array $handler_config): array {
        // Start with AI parameters
        $merged_data = $ai_parameters;
        
        // Override with system data from handler config (system data takes precedence)
        // The system data should be available in handler_config from the import pipeline
        if (isset($handler_config['venue'])) {
            $merged_data['venue'] = $handler_config['venue'];
        }
        
        if (isset($handler_config['artist'])) {
            $merged_data['artist'] = $handler_config['artist'];
        }
        
        if (isset($handler_config['address'])) {
            $merged_data['address'] = $handler_config['address'];
        }
        
        if (isset($handler_config['startDate'])) {
            $merged_data['startDate'] = $handler_config['startDate'];
        }
        
        if (isset($handler_config['endDate'])) {
            $merged_data['endDate'] = $handler_config['endDate'];
        }
        
        if (isset($handler_config['startTime'])) {
            $merged_data['startTime'] = $handler_config['startTime'];
        }
        
        if (isset($handler_config['endTime'])) {
            $merged_data['endTime'] = $handler_config['endTime'];
        }
        
        if (isset($handler_config['price'])) {
            $merged_data['price'] = $handler_config['price'];
        }
        
        if (isset($handler_config['ticketUrl'])) {
            $merged_data['ticketUrl'] = $handler_config['ticketUrl'];
        }
        
        return $merged_data;
    }
    
    /**
     * Get the user-friendly label for this handler.
     *
     * @return string Handler label.
     */
    public static function get_label(): string {
        return __('Data Machine Events', 'dm-events');
    }
}